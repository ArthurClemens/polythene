{"version":3,"file":"polythene-core-tabs.js","sources":["../../polythene-css-classes/tabs.js","../../polythene-css-classes/button.js","../src/Tabs.js","../src/ScrollButton.js","../src/Tab.js"],"sourcesContent":["import buttonClasses from \"./button\";\n\nexport default {\n  component:            \"pe-tabs\",\n\n  // elements\n  indicator:            \"pe-tabs__indicator\",\n  scrollButton:         \"pe-tabs__scroll-button\",\n  scrollButtonAtEnd:    \"pe-tabs__scroll-button-end\",\n  scrollButtonAtStart:  \"pe-tabs__scroll-button-start\",\n  tab:                  \"pe-tab\",\n  tabContent:           \"pe-tabs__tab-content\",\n  tabRow:               \"pe-tabs__row\",\n\n  // states\n  activeSelectable:     \"pe-tabs__active--selectable\",\n  isAtEnd:              \"pe-tabs--end\",\n  isAtStart:            \"pe-tabs--start\",\n  isAutofit:            \"pe-tabs--autofit\",\n  isMenu:               \"pe-tabs--menu\",\n  scrollable:           \"pe-tabs--scrollable\",\n  compactTabs:          \"pe-tabs--compact\",\n  tabHasIcon:           \"pe-tabs__tab--icon\",\n  tabRowCentered:       \"pe-tabs__row--centered\",\n  tabRowIndent:         \"pe-tabs__row--indent\",\n\n  // lookup\n  label:                buttonClasses.label\n};","\nexport default {\n  component:        \"pe-text-button\",\n  super:            \"pe-button\",\n  row:              \"pe-button-row\",\n      \n  // elements      \n  content:          \"pe-button__content\",\n  label:            \"pe-button__label\",\n  textLabel:        \"pe-button__text-label\",\n  wash:             \"pe-button__wash\",\n  washColor:        \"pe-button__wash-color\",\n  dropdown:         \"pe-button__dropdown\",\n      \n  // states      \n  border:           \"pe-button--border\",\n  contained:        \"pe-button--contained\",\n  disabled:         \"pe-button--disabled\",\n  dropdownClosed:   \"pe-button--dropdown-closed\",\n  dropdownOpen:     \"pe-button--dropdown-open\",\n  extraWide:        \"pe-button--extra-wide\",\n  hasDropdown:      \"pe-button--dropdown\",\n  highLabel:        \"pe-button--high-label\",\n  inactive:         \"pe-button--inactive\",\n  raised:           \"pe-button--raised\",\n  selected:         \"pe-button--selected\",\n  separatorAtStart: \"pe-button--separator-start\",\n  hasHover:         \"pe-button--has-hover\",\n};\n","import { filterSupportedAttributes, isTouch, subscribe, unsubscribe, isRTL } from \"polythene-core\";\nimport { scrollTo } from \"polythene-utilities\";\nimport classes from \"polythene-css-classes/tabs\";\n\nconst SCROLL_SPEED                 = 600; // px per second\nconst SCROLL_DELAY                 = .15; // seconds\nconst SCROLL_MIN_DURATION          = .5; // seconds\nconst INDICATOR_SLIDE_MIN_DURATION = .25; // seconds\n\nconst getButtons = props => {\n  return props.content\n    ? props.content\n    : props.tabs\n      ? props.tabs\n      : props.children || [];\n};\n\nconst getIndex = props => {\n  const buttons = getButtons(props);\n  const selectedIndex = Array.isArray(buttons)\n    ? buttons.reduce((acc, tab, index) => (\n      acc === undefined && !tab.disabled && tab.selected  \n        ? index\n        : acc\n    ), undefined)\n    : undefined;\n  if (selectedIndex !== undefined) {\n    return selectedIndex;\n  }\n  const attrsSelectedTabIndex = props.selectedTabIndex !== undefined\n    ? props.selectedTabIndex\n    : props.selectedTab !== undefined // deprecated\n      ? props.selectedTab\n      : undefined;\n  return attrsSelectedTabIndex !== undefined\n    ? attrsSelectedTabIndex\n    : 0;\n};\n\nconst scrollButtonGetNewIndex = (index, tabs) => {\n  const minTabIndex = 0;\n  const maxTabIndex = tabs.length - 1;\n  return {\n    backward: Math.max(index - 1, minTabIndex),\n    forward: Math.min(index + 1, maxTabIndex)\n  };\n};\n\nconst sortByLargestWidth = (a, b) =>\n  a < b\n    ? 1\n    : a > b\n      ? -1\n      : 0;\n\nexport const _Tabs = ({ h, a, getRef, useRef, useState, useEffect, ScrollButton, Tab, ...props }) => {\n  const buttons = getButtons(props);\n  if (buttons.length === 0) {\n    throw new Error(\"No tabs specified\");\n  }\n\n  const [domElement, setDomElement] = useState();\n  const [RTL, setRTL] = useState(false);\n  const tabIndex = getIndex(props) || 0;\n  const selectedTabIndexRef = useRef(tabIndex);\n  const [isScrollButtonAtStart, setIsScrollButtonAtStart] = useState(false);\n  const [isScrollButtonAtEnd, setIsScrollButtonAtEnd] = useState(false);\n  const [tabs, setTabs] = useState([]);\n  const [previousSelectedTabIndex, setPreviousSelectedTabIndex] = useState();\n\n  const managesScroll = props.scrollable && !isTouch;\n  const tabRowElement = domElement && domElement.querySelector(`.${classes.tabRow}`);\n  const tabIndicatorElement = domElement && domElement.querySelector(`.${classes.indicator}`);\n  const isTabsInited = !!domElement && tabs.length === buttons.length;\n  \n  useEffect(\n    () => {\n      if (!tabRowElement) return;\n      const tabRowTabs = [...tabRowElement.querySelectorAll(\"[data-index]\")].map(dom => {\n        const index = parseInt(dom.getAttribute(\"data-index\"), 10);\n        return {\n          dom,\n          options: buttons[index]\n        };\n      });\n      if (tabRowTabs) {\n        setTabs(tabRowTabs);\n      }\n    },\n    [tabRowElement]\n  );\n\n  const handleScrollButtonClick = (e, direction ) => {\n    e.stopPropagation();\n    e.preventDefault();\n    const newIndex = scrollButtonGetNewIndex(selectedTabIndexRef.current, tabs)[direction];\n    if (newIndex !== selectedTabIndexRef.current) {\n      updateWithTabIndex({ index: newIndex, animate: true });\n    } else {\n      scrollToTab(newIndex);\n    }\n  };\n\n  const updateScrollButtons = () => {\n    const scrollLeft = tabRowElement.scrollLeft;\n    const minTabIndex = 0;\n    const maxTabIndex = tabs.length - 1;\n    const isAtStart = (tabRowElement.scrollLeft === 0) && (selectedTabIndexRef.current === minTabIndex);\n    const isAtEnd = (scrollLeft >= (tabRowElement.scrollWidth - domElement.getBoundingClientRect().width - 1)) && (selectedTabIndexRef.current === maxTabIndex);\n    setIsScrollButtonAtStart(isAtStart);\n    setIsScrollButtonAtEnd(isAtEnd);\n  };\n\n  const updateIndicator = ({ selectedTabElement, animate }) => {\n    if (!tabIndicatorElement) {\n      return;\n    }\n    const parentRect = domElement.getBoundingClientRect();\n    const rect = selectedTabElement.getBoundingClientRect();\n    const buttonSize = managesScroll ? rect.height : 0;\n    const translateX = RTL\n      ? rect.right - parentRect.right + tabRowElement.scrollLeft + buttonSize\n      : rect.left - parentRect.left + tabRowElement.scrollLeft - buttonSize;\n    const scaleX = 1 / (parentRect.width - 2 * buttonSize) * rect.width;\n    const transformCmd = `translate(${translateX}px, 0) scaleX(${scaleX})`;\n    const duration = animate\n      ? INDICATOR_SLIDE_MIN_DURATION\n      : 0;\n    const style = tabIndicatorElement.style;\n    style[\"transition-duration\"] = duration + \"s\";\n    style.opacity = 1;\n    style.transform = transformCmd;\n  };\n\n  const scrollToTab = tabIndex => {\n    const scroller = tabRowElement;\n    // Scroll to position of selected tab\n    const tabLeft = tabs.slice(0, tabIndex).reduce((totalWidth, tabData) =>\n      totalWidth + tabData.dom.getBoundingClientRect().width, 0);\n    // Tabs at the far right will not fully move to the left\n    // because the scrollable row will stick to the right \n    // to get the max scroll left, we subtract the visible viewport from the scroll width\n    const scrollerWidth = scroller.getBoundingClientRect().width; // frame width\n    const scrollingWidth = scroller.scrollWidth;\n    const maxScroll = scrollingWidth - scrollerWidth;\n    const left = RTL\n      ? -1 * Math.min(tabLeft, maxScroll)\n      : Math.min(tabLeft, maxScroll);\n    const currentLeft = scroller.scrollLeft;\n    if (currentLeft !== left) {\n      const duration = Math.abs(currentLeft - left) / SCROLL_SPEED;\n      const delaySeconds = SCROLL_DELAY;\n      setTimeout(() => {\n        scrollTo({\n          element: scroller,\n          to: left,\n          duration: Math.max(SCROLL_MIN_DURATION, duration),\n          direction: \"horizontal\"\n        }).then(updateScrollButtons);\n      }, delaySeconds * 1000);\n    }\n  };\n\n  const updateWithTabIndex = ({ index, animate }) => {\n    if (!tabs || !tabs.length) {\n      return;\n    }\n    selectedTabIndexRef.current = index;\n    const selectedTabElement = tabs[index].dom;\n    if (selectedTabElement) {\n      updateIndicator({ selectedTabElement, animate });\n    }\n    if (managesScroll) {\n      updateScrollButtons();\n    }\n    scrollToTab(index);\n    if (props.onChange) {\n      props.onChange({\n        index,\n        options: tabs[index].options,\n        el: selectedTabElement\n      });\n    }\n  };\n\n  useEffect(\n    () => {\n      if (!isTabsInited) {\n        return;\n      }\n      setRTL(isRTL({ element: domElement }));\n      \n      const redrawLargestWidth = () => {\n        if (props.largestWidth) {\n          const widths = tabs.map(({ dom }) => dom.getBoundingClientRect().width);\n          const largest = widths.sort(sortByLargestWidth)[0];\n          tabs.forEach(({ dom }) => dom.style.width = largest + \"px\");\n        }\n      };\n    \n      const redraw = () => {\n        redrawLargestWidth();\n        updateWithTabIndex({ index: selectedTabIndexRef.current, animate: false });\n      };\n    \n      const handleFontEvent = ({ name }) =>\n        name === \"active\" || name === \"inactive\"\n          ? redraw()\n          : null;\n    \n      subscribe(\"resize\", redraw);\n      subscribe(\"webfontloader\", handleFontEvent);\n            \n      redraw();\n\n      return () => {\n        unsubscribe(\"resize\", redraw);\n        unsubscribe(\"webfontloader\", handleFontEvent);\n      };\n    },\n    [isTabsInited]\n  );\n\n  const autofit = props.scrollable || props.centered\n    ? false\n    : props.autofit\n      ? true\n      : false;\n\n  // Keep selected tab up to date\n  if (tabIndex !== undefined && previousSelectedTabIndex !== tabIndex) {\n    updateWithTabIndex({ index: tabIndex, animate: true });\n  }\n  if (previousSelectedTabIndex !== tabIndex) {\n    setPreviousSelectedTabIndex(tabIndex);\n  }\n\n  const componentProps = Object.assign(\n    {},\n    getRef(dom => dom && !domElement && (\n      setTimeout(() => setDomElement(dom), 0) // delay for Mithril 1.x\n    )),\n    filterSupportedAttributes(props),\n    props.testId && { \"data-test-id\": props.testId },\n    {\n      className: [\n        classes.component,\n        props.scrollable ? classes.scrollable : null,\n        isScrollButtonAtStart ? classes.isAtStart : null,\n        isScrollButtonAtEnd ? classes.isAtEnd : null,\n        props.activeSelected ? classes.activeSelectable : null,\n        autofit ? classes.isAutofit : null,\n        props.compact ? classes.compactTabs : null,\n        props.menu ? classes.isMenu : null,\n        props.tone === \"dark\" ? \"pe-dark-tone\" : null,\n        props.tone === \"light\" ? \"pe-light-tone\" : null,\n        props.className || props[a.class],\n      ].join(\" \")\n    }\n  );\n\n  const tabRow = buttons.map((buttonOpts = {}, index) => {\n    const buttonOptsCombined = Object.assign(\n      {},\n      buttonOpts,\n      {\n        // These options can be overridden by `all`\n        selected: index === selectedTabIndexRef.current,\n        animateOnTap: (props.animateOnTap !== false) ? true : false\n      },\n      props.all,\n      {\n        // Internal options, should not get overridden\n        index,\n        onSelect: () => \n          updateWithTabIndex({\n            index,\n            animate: props.noIndicatorSlide\n              ? false\n              : true\n          }),\n      }\n    );\n    return h(Tab, buttonOptsCombined);\n  });\n\n  let scrollButtonAtStart = null, scrollButtonAtEnd = null;\n  if (props.scrollable) {\n    scrollButtonAtStart = h(ScrollButton, Object.assign(\n      {},\n      {\n        icon: props.scrollIconBackward,\n        className: classes.scrollButtonAtStart,\n        position: \"start\",\n        events: {\n          [a.onclick]: e => handleScrollButtonClick(e, \"backward\")\n        },\n        isRTL: RTL\n      }\n    ));\n    scrollButtonAtEnd = h(ScrollButton, Object.assign(\n      {},\n      {\n        icon: props.scrollIconForward,\n        className: classes.scrollButtonAtEnd,\n        position: \"end\",\n        events: {\n          [a.onclick]: e => handleScrollButtonClick(e, \"forward\")\n        },\n        isRTL: RTL\n      }\n    ));\n  }\n\n  const tabIndicator = props.hideIndicator\n    ? null\n    : h(\"div\",\n      {\n        className: classes.indicator\n      }\n    );\n\n  const componentContent = [\n    scrollButtonAtStart,\n    h(\"div\",\n      {\n        className: [\n          classes.tabRow,\n          props.centered ? classes.tabRowCentered : null,\n          props.scrollable ? classes.tabRowIndent : null\n        ].join(\" \")\n      },\n      [\n        ...tabRow,\n        tabIndicator\n      ]\n    ),\n    scrollButtonAtEnd,\n  ];\n\n  return h(\"div\",\n    componentProps,\n    [\n      props.before,\n      ...componentContent,\n      props.after\n    ]\n  );\n};\n","import classes from \"polythene-css-classes/tabs\";\n\nconst arrowBackward = \"<svg width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\"><path d=\\\"M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z\\\"/></svg>\";\nconst arrowForward = \"<svg width=\\\"24\\\" height=\\\"24\\\" viewBox=\\\"0 0 24 24\\\"><path d=\\\"M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z\\\"/></svg>\";\n\nexport const _ScrollButton = ({ h, a, IconButton, ...props }) => {\n\n  const icon = props.position === \"start\"\n    ? props.icon || { svg: { content: h.trust(props.isRTL ? arrowForward : arrowBackward) } }\n    : props.icon || { svg: { content: h.trust(props.isRTL ? arrowBackward : arrowForward) } };\n\n  const componentProps = Object.assign({}, \n    {\n      className: [\n        classes.scrollButton,\n        props.className || props[a.class]\n      ].join(\" \"),\n      icon,\n      ripple: { center: true },\n      events: props.events,\n    }\n  );\n  return h(IconButton, componentProps);\n};\n\n","import classes from \"polythene-css-classes/tabs\";\n\nexport const _Tab = ({ h, a, Button, Icon, ...props }) => {\n\n  // Let internal onclick function co-exist with passed button option\n  const events = props.events || {};\n  events[a.onclick] = events[a.onclick] || (() => {});\n\n  const componentProps = Object.assign({}, \n    props,\n    props.testId && { \"data-test-id\": props.testId },\n    {\n      \"data-index\": props.index,\n      content: h(\"div\",\n        { className: classes.tabContent },\n        [\n          props.icon ? h(Icon, props.icon) : null,\n          props.label\n            ? h(\"div\",\n              { className: classes.label },\n              h(\"span\", props.label)\n            )\n            : null,\n        ]),\n      className: [\n        classes.tab,\n        props.icon && props.label ? classes.tabHasIcon : null,\n        props.className || props[a.class],\n      ].join(\" \"),\n      selected: props.selected,\n      wash: false,\n      ripple: true,\n      events: Object.assign(\n        {},\n        events,\n        {\n          [a.onclick]: e => {\n            props.onSelect();\n            events[a.onclick](e);\n          }\n        }\n      )\n    }\n  );\n\n  const content = props.children;\n  return h(Button, componentProps, content);\n};\n"],"names":["component","indicator","scrollButton","scrollButtonAtEnd","scrollButtonAtStart","tab","tabContent","tabRow","activeSelectable","isAtEnd","isAtStart","isAutofit","isMenu","scrollable","compactTabs","tabHasIcon","tabRowCentered","tabRowIndent","label","getButtons","props","content","tabs","children","sortByLargestWidth","a","b","arrowBackward","arrowForward","h","IconButton","icon","position","svg","trust","isRTL","_extends","className","classes","join","ripple","center","events","Button","Icon","onclick","componentProps","testId","index","selected","wash","e","onSelect","getRef","useRef","useState","useEffect","ScrollButton","Tab","buttons","length","Error","domElement","setDomElement","RTL","setRTL","tabIndex","selectedIndex","Array","isArray","reduce","acc","undefined","disabled","attrsSelectedTabIndex","selectedTabIndex","selectedTab","getIndex","selectedTabIndexRef","isScrollButtonAtStart","setIsScrollButtonAtStart","isScrollButtonAtEnd","setIsScrollButtonAtEnd","setTabs","previousSelectedTabIndex","setPreviousSelectedTabIndex","managesScroll","isTouch","tabRowElement","querySelector","tabIndicatorElement","isTabsInited","tabRowTabs","_toConsumableArray","querySelectorAll","map","dom","parseInt","getAttribute","options","handleScrollButtonClick","direction","stopPropagation","preventDefault","newIndex","maxTabIndex","backward","Math","max","forward","min","scrollButtonGetNewIndex","current","updateWithTabIndex","animate","scrollToTab","updateScrollButtons","scrollLeft","scrollWidth","getBoundingClientRect","width","scroller","tabLeft","slice","totalWidth","tabData","scrollerWidth","maxScroll","left","currentLeft","duration","abs","setTimeout","scrollTo","element","to","then","delaySeconds","selectedTabElement","parentRect","rect","buttonSize","height","translateX","right","scaleX","transformCmd","style","opacity","transform","updateIndicator","onChange","el","redraw","largestWidth","largest","sort","forEach","redrawLargestWidth","handleFontEvent","name","subscribe","unsubscribe","autofit","centered","filterSupportedAttributes","activeSelected","compact","menu","tone","buttonOpts","buttonOptsCombined","animateOnTap","all","noIndicatorSlide","scrollIconBackward","scrollIconForward","tabIndicator","hideIndicator","componentContent","before","after"],"mappings":"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"}