{"version":3,"sources":["tabs.es6"],"names":["require","_polythene","_events","_mithril","_button","_icon","_iconButton","_scrollTo","_theme","_config","CSS_CLASSES","block","scrollButton","scrollButtonLeft","scrollButtonRight","scrollButtonOffset","tabRow","tabRowCentered","tabRowIndent","tab","tabContent","tabHasIcon","indicator","scrollable","isAutofit","isAtStart","isAtEnd","isMenu","isSmall","activeSelected","label","POSITION_LEFT","POSITION_RIGHT","getNewIndex","index","tabs","minTabIndex","maxTabIndex","length","left","Math","max","right","min","handleScrollButtonClick","ctrl","opts","e","direction","stopPropagation","preventDefault","currentTabIndex","selectedTabIndex","newIndex","scrollToTab","setSelectedTab","_mithril2","default","redraw","createScrollButton","position","scrollIconForward","_theme2","arrowForward","scrollIconBackward","arrowBackward","component","_iconButton2","class","join","icon","ripple","center","config","el","scrollButtonLeftEl","scrollButtonRightEl","events","onclick","alignToTitle","firstTab","firstInnerLabel","querySelector","firstOuterLabelWidth","getBoundingClientRect","width","firstInnerLabelWidth","firstTabOffset","style","marginLeft","createRightButtonOffset","scrollButtonRightWidth","scrollButtonOffsetEl","tabsEl","tabIndex","scroller","scrollerEl","tabLeft","slice","reduce","totalWidth","tabData","scrollerWidth","scrollingWidth","scrollWidth","maxScroll","currentLeft","scrollLeft","duration","abs","_config2","tabs_scroll_speed","delaySeconds","tabs_scroll_delay","setTimeout","_scrollTo2","element","to","tabs_scroll_min_duration","updateScrollButtons","isAtLeft","isAtRight","scrollButtonStates","animateIndicator","selectedTabEl","animate","parentRect","rect","tabIndicatorEl","translateX","transformCmd","indicator_slide_min_duration","transform","managesScroll","getState","data","createTab","buttonOpts","tabButtonOptions","Object","assign","content","_icon2","wash","noIndicatorSlide","inited","push","_button2","sortNumbers","a","b","createView","arguments","undefined","tag","autofit","centered","selectedTab","previousOptsSelectedTab","props","menu","small","id","context","largestWidth","widths","map","largest","sort","reverse","forEach","_polythene2","isTouch","onResize","_events2","subscribe","onunload","unsubscribe","buttons","buttonOptsCombined","selected","animateOnTap","tabsOpts","concat","tabIndicator","hideIndicator","onscroll","before","after","controller","view"],"mappings":"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","file":"tabs.js","sourcesContent":["import 'polythene/common/object.assign';\nimport p from 'polythene/polythene/polythene';\nimport events from 'polythene/common/events';\nimport m from 'mithril';\nimport button from 'polythene/button/button';\nimport icon from 'polythene/icon/icon';\nimport iconBtn from 'polythene/icon-button/icon-button';\nimport scrollTo from 'polythene/common/scroll-to';\nimport theme from 'polythene/tabs/theme/theme'; // contains icons\nimport config from 'polythene/tabs/theme/config';\n\nconst CSS_CLASSES = {\n    block: 'pe-tabs',\n    scrollButton: 'pe-tabs__scroll-button',\n    scrollButtonLeft: 'pe-tabs__scroll-button--start',\n    scrollButtonRight: 'pe-tabs__scroll-button--end',\n    scrollButtonOffset: 'pe-tabs__scroll-button--offset',\n    tabRow: 'pe-tabs__row',\n    tabRowCentered: 'pe-tabs__row--centered',\n    tabRowIndent: 'pe-tabs__row--indent',\n    tab: 'pe-tabs__tab',\n    tabContent: 'pe-tabs__tab-content',\n    tabHasIcon: 'pe-tabs__tab---icon',\n    indicator: 'pe-tabs__indicator',\n    scrollable: 'pe-tabs--scrollable',\n    isAutofit: 'pe-tabs--autofit',\n    isAtStart: 'pe-tabs--start',\n    isAtEnd: 'pe-tabs--end',\n    isMenu: 'pe-tabs--menu',\n    isSmall: 'pe-tabs--small',\n    activeSelected: 'pe-tabs__active-selected',\n    // lookup:\n    label: 'pe-button__label',\n};\n\nconst POSITION_LEFT = (1 << 1);\nconst POSITION_RIGHT = (1 << 2);\n\nconst getNewIndex = (index, tabs) => {\n    const minTabIndex = 0;\n    const maxTabIndex = tabs.length - 1;\n    return {\n        left: Math.max(index - 1, minTabIndex),\n        right: Math.min(index + 1, maxTabIndex)\n    };\n};\n\nconst handleScrollButtonClick = (ctrl, opts, e, direction) => {\n    e.stopPropagation();\n    e.preventDefault();\n    const tabs = ctrl.tabs;\n    const currentTabIndex = ctrl.selectedTabIndex;\n    const newIndex = getNewIndex(currentTabIndex, tabs)[direction];\n    scrollToTab(ctrl, newIndex);\n    if (newIndex !== currentTabIndex) {\n        setSelectedTab(ctrl, opts, newIndex, true);\n        m.redraw();\n    }\n};\n\n\nconst createScrollButton = (ctrl, position, opts) => {\n    const scrollIconForward = opts.scrollIconForward || theme.arrowForward;\n    const scrollIconBackward = opts.scrollIconBackward || theme.arrowBackward;\n\n    return m.component(iconBtn, {\n        class: [\n            CSS_CLASSES.scrollButton,\n            (position === POSITION_LEFT ? CSS_CLASSES.scrollButtonLeft : CSS_CLASSES.scrollButtonRight)\n        ].join(' '),\n        icon: position === POSITION_LEFT ? scrollIconBackward : scrollIconForward,\n        ripple: {\n            center: true\n        },\n        config: (el) => {\n            if (ctrl.scrollButtonLeftEl && ctrl.scrollButtonRightEl) {\n                return;\n            }\n            if (position === POSITION_LEFT) {\n                ctrl.scrollButtonLeftEl = el;\n            } else {\n                ctrl.scrollButtonRightEl = el;\n            }\n        },\n        events: {\n            onclick: (position === POSITION_LEFT) ? (e) => {\n                handleScrollButtonClick(ctrl, opts, e, 'left');\n            } : (e) => {\n                handleScrollButtonClick(ctrl, opts, e, 'right');\n            }\n        }\n    });\n};\n\nconst alignToTitle = (ctrl) => {\n    const firstTab = ctrl.tabs[0].el;\n    const firstInnerLabel = firstTab.querySelector('.' + CSS_CLASSES.label + ' span');\n    const firstOuterLabelWidth = firstTab.getBoundingClientRect().width;\n    const firstInnerLabelWidth = firstInnerLabel.getBoundingClientRect().width;\n    const firstTabOffset = (firstOuterLabelWidth - firstInnerLabelWidth) / 2;\n    firstTab.style.marginLeft = -firstTabOffset + 'px';\n};\n\nconst createRightButtonOffset = (ctrl) => {\n    // add padding to right so that last item is not hidden behind scroll button\n    const scrollButtonRightWidth = ctrl.scrollButtonRightEl.getBoundingClientRect().width;\n    const scrollButtonOffsetEl = ctrl.tabsEl.querySelector('.' + CSS_CLASSES.scrollButtonOffset);\n    scrollButtonOffsetEl.style.width = scrollButtonRightWidth + 'px';\n};\n\nconst scrollToTab = (ctrl, tabIndex) => {\n    const tabs = ctrl.tabs;\n    const scroller = ctrl.scrollerEl;\n    // scroll to position of selected tab\n    const tabLeft = tabs.slice(0, tabIndex).reduce((totalWidth, tabData) => {\n        return totalWidth + tabData.el.getBoundingClientRect().width;\n    }, 0);\n    // tabs at the far right will not fully move to the left\n    // because the scrollable row will stick to the right \n    // to get the max scroll left, we subtract the visible viewport from the scroll width\n    const scrollerWidth = scroller.getBoundingClientRect().width; // frame width\n    const scrollingWidth = scroller.scrollWidth;\n    const maxScroll = scrollingWidth - scrollerWidth;\n    const left = Math.min(tabLeft, maxScroll);\n    const currentLeft = scroller.scrollLeft;\n    if (currentLeft !== left) {\n        const duration = Math.abs(currentLeft - left) / config.tabs_scroll_speed;\n        const delaySeconds = config.tabs_scroll_delay || 0;\n        setTimeout(() => {\n            scrollTo({\n                element: scroller,\n                to: left,\n                duration: Math.max(config.tabs_scroll_min_duration, duration),\n                direction: 'horizontal'\n            });\n        }, delaySeconds * 1000);\n    }\n};\n\nconst updateScrollButtons = (ctrl) => {\n    const scrollerEl = ctrl.scrollerEl;\n    const scrollLeft = scrollerEl.scrollLeft;\n    const currentTabIndex = ctrl.selectedTabIndex;\n    const tabs = ctrl.tabs;\n    const tabsEl = ctrl.tabsEl;\n    const minTabIndex = 0;\n    const maxTabIndex = tabs.length - 1;\n    const isAtLeft = (scrollerEl.scrollLeft === 0) && (currentTabIndex === minTabIndex);\n    const isAtRight = (scrollLeft >= (scrollerEl.scrollWidth - tabsEl.getBoundingClientRect().width - 1)) && (currentTabIndex === maxTabIndex);\n    ctrl.scrollButtonStates.left = !isAtLeft;\n    ctrl.scrollButtonStates.right = !isAtRight;\n};\n\nconst animateIndicator = (selectedTabEl, animate, ctrl) => {\n    const parentRect = ctrl.tabsEl.getBoundingClientRect();\n    const rect = selectedTabEl.getBoundingClientRect();\n    const style = ctrl.tabIndicatorEl.style;\n    const translateX = rect.left - parentRect.left + ctrl.scrollerEl.scrollLeft;\n    const transformCmd = 'translate(' + translateX + 'px, 0)';\n    const duration = animate ? config.indicator_slide_min_duration : 0;\n    // use width instead of scale to please IE10\n    style.width = rect.width + 'px';\n    style['transition-duration'] =\n        style['-webkit-transition-duration'] =\n        style['-moz-transition-duration'] =\n        style['-o-transition-duration'] = duration + 's';\n    style.transform =\n        style['-webkit-transform'] =\n        style['-moz-transform'] =\n        style['-ms-transform'] =\n        style['-o-transform'] = transformCmd;\n};\n\nconst setSelectedTab = (ctrl, opts, index, animate) => {\n    ctrl.selectedTabIndex = index;\n    if (!ctrl.tabs.length) return;\n    const selectedTabEl = ctrl.tabs[index].el;\n    if (selectedTabEl && ctrl.tabIndicatorEl && ctrl.tabsEl) {\n        animateIndicator(selectedTabEl, animate, ctrl);\n    }\n    if (ctrl.managesScroll) {\n        updateScrollButtons(ctrl);\n        scrollToTab(ctrl, index);\n    }\n    if (opts.getState) {\n        opts.getState({\n            index: index,\n            data: ctrl.tabs[index].data,\n            el: selectedTabEl\n        });\n    }\n};\n\nconst createTab = (ctrl, opts, index, buttonOpts) => {\n    // Let internal onclick function co-exist with passed button option\n    buttonOpts.events = buttonOpts.events || {};\n    buttonOpts.events.onclick = buttonOpts.events.onclick || (() => {});\n    const tabButtonOptions = Object.assign(\n        {},\n        buttonOpts,\n        {\n            content: m('div', {\n                class: CSS_CLASSES.tabContent\n            }, [\n                buttonOpts.icon ? m.component(icon, buttonOpts.icon) : null,\n                buttonOpts.label ? m('div', {class: CSS_CLASSES.label}, m('span', buttonOpts.label)) : null,\n            ]),\n            class: [\n                CSS_CLASSES.tab,\n                (buttonOpts.icon && buttonOpts.label ? CSS_CLASSES.tabHasIcon : null),\n                buttonOpts.class\n            ].join(' '),\n            wash: false,\n            ripple: true,\n            events: Object.assign(\n                {},\n                buttonOpts.events,\n                {\n                    onclick: (e) => {\n                        setSelectedTab(ctrl, opts, index, opts.noIndicatorSlide ? false : true);\n                        buttonOpts.events.onclick(e);\n                    }\n                }\n            ),\n            config: (el, inited) => {\n                if (inited) {\n                    return;\n                }\n                ctrl.tabs.push({data: buttonOpts, el});\n            }\n        }\n    );\n    return m.component(button, tabButtonOptions);\n};\n\nconst sortNumbers = (a, b) => {\n    if (a < b)\n        return -1;\n    if (a > b)\n        return 1;\n    else\n        return 0;\n};\n\nconst createView = (ctrl, opts = {}) => {\n    const tag = opts.tag || 'div';\n    const autofit = (opts.scrollable || opts.centered) ? false : (opts.autofit ? true : false);\n\n    // keep selected tab up to date\n    if (opts.selectedTab !== undefined && ctrl.previousOptsSelectedTab !== opts.selectedTab) {\n        setSelectedTab(ctrl, opts, opts.selectedTab, true);\n    }\n    ctrl.previousOptsSelectedTab = opts.selectedTab;\n\n    const props = {\n        class: [\n            CSS_CLASSES.block,\n            (opts.scrollable ? CSS_CLASSES.scrollable : null),\n            ((ctrl.selectedTabIndex === 0) ? CSS_CLASSES.isAtStart : null),\n            ((ctrl.selectedTabIndex === ctrl.tabs.length - 1) ? CSS_CLASSES.isAtEnd : null),\n            (opts.activeSelected ? CSS_CLASSES.activeSelected : null),\n            (autofit ? CSS_CLASSES.isAutofit : null),\n            (opts.menu ? CSS_CLASSES.isMenu : null),\n            (opts.small ? CSS_CLASSES.isSmall : null),\n            opts.class\n        ].join(' '),\n        id: opts.id || '',\n        config: (el, inited, context) => {\n            if (inited) {\n                return;\n            }\n            ctrl.tabsEl = el;\n\n            if (opts.largestWidth) {\n                const widths = ctrl.tabs.map(tabData => tabData.el.getBoundingClientRect().width);\n                const largest = widths.sort(sortNumbers).reverse()[0];\n                ctrl.tabs.forEach(tabData => tabData.el.style.width = largest + 'px');\n            }\n\n            // align first scrollable tab to title\n            if (opts.scrollable) {\n                alignToTitle(ctrl);\n            }\n            // handle scroll\n            if (opts.scrollable && !p.isTouch) {\n                ctrl.managesScroll = true;\n                createRightButtonOffset(ctrl);\n            }\n\n            const onResize = () => {\n                setSelectedTab(ctrl, opts, ctrl.selectedTabIndex, false);\n                m.redraw();\n            };\n            events.subscribe('resize', onResize);\n\n            context.onunload = () => {\n                events.unsubscribe('resize', onResize);\n            };\n\n            setSelectedTab(ctrl, opts, ctrl.selectedTabIndex, false);\n        }\n    };\n    const tabRow = opts.buttons.map((buttonOpts, index) => {\n        const buttonOptsCombined = Object.assign(\n            {},\n            buttonOpts,\n            {\n                selected: index === ctrl.selectedTabIndex,\n                animateOnTap: (opts.animateOnTap !== false) ? true : false\n            },\n            opts.tabsOpts || {}\n        );\n        return createTab(ctrl, opts, index, buttonOptsCombined);\n    }).concat([\n        // offset for right scroll button\n        opts.scrollable ? m('div', {class: CSS_CLASSES.scrollButtonOffset}) : null\n    ]);\n\n    let scrollButtonLeft, scrollButtonRight;\n    if (opts.scrollable) {\n        scrollButtonLeft = createScrollButton(ctrl, POSITION_LEFT, opts);\n        scrollButtonRight = createScrollButton(ctrl, POSITION_RIGHT, opts);\n    }\n\n    const tabIndicator = opts.hideIndicator ? null : m('div', {\n        class: CSS_CLASSES.indicator,\n        config: (el, inited) => {\n            if (inited) {\n                return;\n            }\n            ctrl.tabIndicatorEl = el;\n        }\n    });\n\n    const content = [\n        opts.scrollable ? scrollButtonLeft : null,\n        m('div', {\n            class: [\n                CSS_CLASSES.tabRow,\n                (opts.centered ? CSS_CLASSES.tabRowCentered : null),\n                (opts.scrollable ? CSS_CLASSES.tabRowIndent : null)\n            ].join(' '),\n            config: (el, inited) => {\n                if (inited) {\n                    return;\n                }\n                ctrl.scrollerEl = el;\n            },\n            onscroll: () => {\n                updateScrollButtons(ctrl);\n            }\n        }, [\n            tabRow,\n            tabIndicator\n        ]),\n        opts.scrollable ? scrollButtonRight : null\n    ];\n    return m(tag, props, [opts.before, content, opts.after]);\n};\n\nconst component = {\n    controller: () => {\n        return {\n            tabsEl: null,\n            scrollerEl: null,\n            tabs: [], // {data, el}\n            tabIndicatorEl: null,\n            selectedTabIndex: 0,\n            previousOptsSelectedTab: undefined,\n            managesScroll: false,\n            scrollButtonStates: {\n                left: false,\n                right: false\n            }\n        };\n    },\n    view: (ctrl, opts = {}) => {\n        return createView(ctrl, opts);\n    }\n};\n\nexport default component;\n"]}